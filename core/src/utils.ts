import * as ethers from "ethers";
import { DemoApp, DemoApp__factory } from "../typechain-types";
import * as fs from "fs";
import * as path from "path";
import { string, option } from "cmd-ts";
import {
  snarkjs,
  Groth16Proof,
  Groth16VerifyingKey,
  SubmissionDescriptor,
} from "@nebrazkp/upa/sdk";

export type Option = ReturnType<typeof option>;

export function demoAppInstance(description?: string | undefined): Option {
  return option({
    type: string,
    long: "instance",
    defaultValue: () => "demo-app.instance",
    description: description || "demo-app instance file",
  });
}

export function circuitWasm(description?: string | undefined): Option {
  return option({
    type: string,
    long: "circuit-wasm",
    defaultValue: () => {
      return findCircuitFile("circuit_js/circuit.wasm");
    },
    description:
      description || "The .wasm file for demo-app generated by Circom",
  });
}

export function circuitZkey(description?: string | undefined): Option {
  return option({
    type: string,
    long: "circuit-zkey",
    defaultValue: () => {
      return findCircuitFile("circuit.zkey");
    },
    description: description || "The .zkey file generated by SnarkJS",
  });
}

export function upaInstance(description?: string | undefined): Option {
  return option({
    type: string,
    long: "upa-instance",
    defaultValue: () => `upa.instance`,
    description: description || "The UPA instance used by demo-app",
  });
}

export function proofOutputFile(description?: string | undefined): Option {
  return option({
    type: string,
    long: "proof-output",
    defaultValue: () => "generated_proofs.json",
    description: description || "Destination file for generated proof data",
  });
}

export function vkFile(description?: string | undefined): Option {
  return option({
    type: string,
    long: "vk-file",
    short: "v",
    defaultValue: () => findCircuitFile("upa_verification_key.json"),
    description: description || "demo-app's verifying key file",
  });
}

export type DemoAppInstance = {
  /// Address of the demo-app contract
  demoApp: string;
  circuitId: string;
  vk: Groth16VerifyingKey;
};

export function loadDemoAppInstance(instance_file: string): DemoAppInstance {
  return JSON.parse(fs.readFileSync(instance_file, "ascii")) as DemoAppInstance;
}

export function demoAppFromInstance(instance_file: string): DemoApp {
  const instance = loadDemoAppInstance(instance_file);
  return DemoApp__factory.connect(instance.demoApp);
}

// Generates a random non-negative solution to the equation a*b = c*d + e + f.
export function generateRandomProofInputs(): {
  a: bigint;
  b: bigint;
  c: bigint;
  d: bigint;
  e: bigint;
  f: bigint;
} {
  const c = BigInt(ethers.hexlify(ethers.randomBytes(4)));
  const d = BigInt(ethers.hexlify(ethers.randomBytes(4)));
  const a = c + 1n;
  const b = d + 1n;
  const e = c;
  const f = d + 1n;
  return { a, b, c, d, e, f };
}

// Attempt to find a file in the `circuits` directory
function findCircuitFile(filename: string): string {
  // Try the expected locations, based on this file being either in /src
  // or /dist/src directories in the package root.

  let f = path.normalize(path.join(__dirname, "..", "circuits", filename));
  if (!fs.existsSync(f)) {
    f = path.normalize(path.join(__dirname, "..", "..", "circuits", filename));
    if (!fs.existsSync(f)) {
      throw "unable to find " + filename + ".  Specify explicitly with flags.";
    }
  }
  return f;
}

/// Generates a random valid snarkjs proof.
export async function generateProof(
  circuitWasm: string,
  circuitZkey: string
): Promise<[Groth16Proof, string[]]> {
  const proofData = await snarkjs.groth16.fullProve(
    generateRandomProofInputs(),
    circuitWasm,
    circuitZkey
  );

  const proof = Groth16Proof.from_snarkjs(proofData.proof);
  const publicInputs: string[] = proofData.publicSignals;

  return [proof, publicInputs];
}

/// Pauses execution for `s` seconds, then resumes.
export function sleep(s: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, 1000 * s));
}

/**
 * Submits a solution to the demo app contract. The solution
 * should already have been verified by the UPA contract.
 *
 * @param wallet - The wallet used to sign the transaction.
 * @param demoApp - The instance of the demo app contract.
 * @param nonce - The nonce value for the transaction.
 * @param submission - The submission object containing the solution.
 * @param solutionIdx - The index of the solution in the submission.
 * @returns A promise that resolves to the transaction response.
 */
export async function submitSolution(
  _wallet: ethers.AbstractSigner,
  demoApp: DemoApp,
  nonce: number,
  submission: SubmissionDescriptor,
  solutionIdx: number
): Promise<ethers.ContractTransactionResponse> {
  const solution = submission.inputs[solutionIdx];
  console.log(`Submitted solution ${solution}`);
  if (submission.isMultiProofSubmission()) {
    // If the proof was part of a multi-proof submission, we
    // need to pass a proof reference to the demo-app
    // contract so it can check the proof's verification
    // status.
    return demoApp.submitSolutionWithProofReference(
      solution,
      submission.computeProofReference(solutionIdx)!.solidity(),
      { nonce: nonce }
    );
  } else {
    // If the proof was sent in a single-proof submission, we
    // only need to pass the solution. A proof reference is not
    // necessary.
    return demoApp.submitSolution(solution, {
      nonce: nonce,
    });
  }
}
